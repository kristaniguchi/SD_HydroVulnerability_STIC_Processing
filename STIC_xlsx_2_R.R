#STIC Data Automation for USGS
  #This script takes CSV outputs from various STIC loggers for a given site and replicates the graphics, calculated variables, and summary statistics from the Excel template
  #By Jessica Weidenfelt and Kris Taniguchi-Quan (SCCWRP)


#clear environment - for testing purposes, cleans working environment
rm(list=ls())

#Install required packages (if needed, only need to install once) 
#install.packages("tidyverse")
#install.packages("janitor")
#install.packages("ggplot2")
#install.package("plyr")
#install.packages("dplyr)

#Load required packages (need to load each session)
library(tidyverse)
library(janitor)
library(ggplot2)
library(plyr)
#library(dplyr)

#Set your working directory to be working from (file path where the csv files are located) [USER DEFINED]
csv.directory <- "C:/Users/KristineT/SCCWRP/SD Hydro Vulnerability Assessment - General/Data/RawData/USGS_STIC_Data_Hydroperiod/SCCWRP_CSV_test/" #update with your file path with csv files
setwd(csv.directory)
#Set output directory where outputs should be saved - subfolder within csv directory
output.directory <- paste0(csv.directory, "Outputs")
#Create output directory (if does not exist already)
dir.create(output.directory)

#Define the site name [USER DEFINED]
site.name <- "Beaver_Hollow"

#List the csv files associated with the site (USER DEFINED until lookup table with serial #, date range, and site.name is created)
#if manually listing csv files for each series, list below in quotes and uncomment line
#csv.file.list <- c("", "", "", "", "") 
#if all files saved in csv.directory are for a given site, then list all files in directory
csv.file.list <- list.files(csv.directory, pattern=".csv")

#loop through each csv file in the directory (series) to be evaluated for given site

for(i in 1:length(csv.file.list)){
  
  #Read in CSV for series i
  csv_data <- read.csv(csv.file.list[i])
  #find original column header names
  orig.colnames <- names(csv_data)
  
  #Clean column names and rename
  csv_data <- csv_data %>%
    clean_names() %>% 
    #rename columns
    dplyr::rename(Date_Time = x,
                  Temp_C=x_1,
                  Intensity_Lux=x_2,
                  Coupler_Detached=x_3,
                  Bad_Battery=x_4,
                  End_File=x_5)
              
  #Remove first row of original unused column names 
  csv_data <- csv_data[-c(1), ]
  
  #Create new data frame using only Date, Temp_C, Intesnity_Lux columns from csv
  series_data <- csv_data %>% 
    select(Date_Time,Temp_C,Intensity_Lux) %>% 
    #Create column with date only, removes timestamp
    mutate(Date = as.Date(Date_Time, format = "%m/%d/%y"))
  
  #Find the serial number from the original csv first column name which is formatted "i_plot_title_serial#"
  STIC_serial <- gsub("i_plot_title_","",colnames(csv_data)[1])
  #Add serial number as a column to output dataframe
  series_data$STIC_serial <- rep(STIC_serial,length(series_data$Date))
  
  #Convert Temperature from character to numeric format
  series_data$Temp_C <- as.numeric(series_data$Temp_C)
  
  #Calculate mean temp
  Temp_Cmean <- mean(series_data$Temp_C)
  
  #Change temp from F to C if Temp_Cmean is > 35
  series_data <- series_data %>%
    mutate(Temp_C= 
             if(Temp_Cmean > 35){
               ((Temp_C-32)* (5/9))
             }else{
               Temp_C
             }
    )

  
  #Format Intensity_Lux (contains , in values, remove and save as numeric vector) 
  series_data$Intensity_Lux <- gsub(',', '', series_data$Intensity_Lux)
  #Convert Intensity_Lux from character to numeric
  series_data$Intensity_Lux <- as.numeric(series_data$Intensity_Lux)
  
  #attach column names in series_data so you can run analysis by using column name only
  attach(series_data)
  
  #apply function to achieve Temp Corrected value
  series_data <- series_data %>% 
    mutate(TempCorrected = 
             Intensity_Lux/(1+((2.1/100)*((Temp_C)-25)))
           )
  
  #attach(series_data)
  
  #create max temperature corrected variable 
  maxTC <- max(series_data$TempCorrected)
  
  #create an equation to use for %RCtempcorrected conditional statements
  temp_equation_1 <- (series_data$TempCorrected/(maxTC*100))
  
  #Manually set "lower % RCcutoff" and "% RCcutoff" numbers
  # May need to adjust RC cut off after looking at "plot1"
  percentRCcutoff <- 0
  lower_percentRCcutoff <- 0
  
  
  #If statements to create pct_Rctempcorrected 
  series_data <- series_data %>%
    mutate(pct_Rctempcorrected =
             #conditional statement that PLEASE ANNOTATE WHAT THIS IS DOING HERE
             case_when(
               #if temp_equation_1  <= lower_percentRCcutoff, PLEASE ANNOTATE WHAT THIS IS DOING HERE
               temp_equation_1 <= "lower_percentRCcutoff" ~ (TempCorrected/maxTC*100),
               #if temp_equation_1  > percentRCcutoff, PLEASE ANNOTATE WHAT THIS IS DOING HERE
               temp_equation_1 > "percentRCcutoff" ~ (TempCorrected/maxTC*100),
               #PLEASE ANNOTATE WHAT THIS IS DOING HERE
               TRUE ~ as.numeric(TempCorrected, na.rm=TRUE)
             )
    )

  
  
  ###Plot timeseries of %RC-temp corrected and Temp C
  #Coefficient to multiply second axis constraints by
  coeff <- .275
  #Colors for lines
  Tempcolor <- "red"
  pct_RCtemp_color <- "blue"
  
  #Creates plot and output
  plot1 <- ggplot(series_data, aes(x=Date)) +
    geom_line( aes(y=Temp_C/coeff, colour="Temperature"),size=1,) + 
    geom_line( aes(y=pct_Rctempcorrected ,  colour="% RC Temp Corrected"),size=1,) +
    scale_y_continuous(sec.axis = sec_axis(~.*coeff, name="Temperature (Â°C)")) + 
    scale_x_date(date_labels="%m/%d/%y",date_breaks  ="1 month") +
    scale_colour_manual(values = c("blue", "red"), name="") +
    labs(y = "% RC-temp corrected",
         x = "Date") +
    theme_bw() +
    theme(axis.line = element_line(colour = "black"),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.background = element_blank(),
          legend.position = "top") 
  
  #Print plot
  print(plot1)
  
  #Set file name and save plot as file name
  file.name <- paste0(output.directory,"/RC_tempcorrected_timeseries_plot_", site.name, "_series", i,".png")
  ggsave(plot1,file =  file.name, width=10, height=4)
  
  #Manually set wet/dry threshold [USER DEFINED]
  wetdry_threshold <- 10
  
  #Create wet_dry column. 0 for dry, 1 for wet 
  series_data <- series_data %>%
    mutate("Wet_Dry"= 
             #ANNOTATE what this is doing
             case_when(Date < 1 ~ (0),
                       #ANNOTATE
                       pct_Rctempcorrected > wetdry_threshold ~ (1),
                       #If true, ANNOTATE
                       TRUE ~ as.numeric(TempCorrected, na.rm=TRUE)
                       )
          )
  
  
  #Find the number of readings that registers as wet, 
  #but have more than 10 readings in a day (5 hours)
  consecutive_wet <- series_data %>% 
    group_by(Wet_Dry, Date) %>%
    summarise(count = sum(Wet_Dry==1)) %>%
    #where did 10 come from?, got slightly different number 78 instead of 74
    filter(count > 10)
  
  #Sum the total number of consecutive wet readings 
  consecutive_wet <- sum(consecutive_wet$count)
  
  #Assign appropriate variable class to output 
  consecutive_wet <- as.numeric(consecutive_wet)
  
  #Divide the number of wet readings by 48 (since there are 48 readings a day)
  #then round the number to nearest whole value
  cons_wet_days <- round_half_up(consecutive_wet/48)
  
  #selects all days that register as wet 
  count_wet_records <- series_data %>% group_by(Wet_Dry, Date) %>%
    summarise(count = sum(Wet_Dry==1))
  
  #Sum all of the count data together
  count_wet_records <- sum(count_wet_records$count)
  #Change number to numeric 
  count_wet_records <- as.numeric(count_wet_records)
  
  #Total number of recordings taken by STIC logger
  RecordSubtotals <- nrow(series_data)
  
  #Change total number of recordings to numeric
  RecordSubtotals <- as.numeric(RecordSubtotals)
  
  #Calculate total number of recordings that do not register as wet 
  Count_Dry_Records <- (RecordSubtotals-count_wet_records)
  
  #Create total number of dry days and rounds to nearest whole number (up and down)
  Days_Dry <- round_half_up(Count_Dry_Records/48)
  #Selects the maximum number of consecutive wet records 
  max_continuous_wet <- max(consecutive_wet)
  #Selects maximum contiuonus wet days 
  MCW_Days <- max(round_half_up(max_continuous_wet/48))
  
  
  pct_wet <- round(count_wet_records/(count_wet_records+RecordSubtotals)*100, digits=0)
  
  
  Summary.Stats <- c(cons_wet_days,count_wet_records,Temp_Cmean,
                     RecordSubtotals,Count_Dry_Records,max_continuous_wet,
                     Days_Dry,MCW_Days)
  
  #List of variable names in summary stats
  summary.stats.names <- c("cons_wet_days","count_wet_records","Temp_Cmean",
                           "RecordSubtotals", "Count_Dry_Records","max_continuous_wet",
                           "Days_Dry", "MCW_Days")
  
  #subbing plot title with nothing
  
  #reminder: add in total number of sets 
  file_name <- paste0("SanDiegoSTICsDataProcess_Sets_",STIC_serial, ".csv")
  write.csv(series_data, file = paste0(colnames(series_data)[1], ".csv"), row.names = TRUE)
  
  #creates new csv file in directory that had previous csv file
  #name will be plot_title_1065276 --> number will change
  #depending on plot title from original csv
  
  
  
}


