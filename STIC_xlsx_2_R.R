#STIC Data Automation for USGS
  #This script takes CSV outputs from various STIC loggers for a given site and replicates the graphics, calculated variables, and summary statistics from the Excel template
  #CSV outputs should be organized in folders by site  
  #By Jessica Weidenfeld and Kris Taniguchi-Quan (SCCWRP)
  
#Data used in this script testing are saved here: https://sccwrp.sharepoint.com/:f:/s/SDHydroVulnerabilityAssessment/EsS86qqut8JCgRVkOthLtFEBFyiiiofBOgFYbRwR1UTwTA?e=9QoS1S 

#added a comment 

#clear environment - for testing purposes, cleans working environment
rm(list=ls())

#Install required packages (if needed, only need to install once).  If installing, uncomment (remove #) install.packages lines and run
#install.packages("tidyverse")
#install.packages("janitor")
#install.packages("ggplot2")
#install.package("plyr")
#install.packages("dplyr)

#Load required packages (need to load each session)
library(tidyverse)
library(janitor)
library(ggplot2)
library(plyr)


# [USER DEFINED] Set your file path where the csv files are located: location of the folder containing csv files for each site
    # you can download and explore the data/folders used in this example here: https://sccwrp.sharepoint.com/:f:/s/SDHydroVulnerabilityAssessment/EqGgb2_-xXpMlftUMSpqauoBJiS8gkt2yYlSq2ziHhhXbg?e=jtQ36K
## Kris directories:
csv.directory <- "C:/Users/KristineT.SCCWRP2K/SCCWRP/SD Hydro Vulnerability Assessment - General/Data/RawData/USGS_STIC_Data_Hydroperiod/SCCWRP_CSV_test/Beaverhollow/" #update with your file path with csv files
#csv.directory <- "C:/Users/KristineT.SCCWRP2K/SCCWRP/SD Hydro Vulnerability Assessment - General/Data/RawData/USGS_STIC_Data_Hydroperiod/SCCWRP_CSV_test/Galloway_Valley_Testdata/Galloway Valley/" #update with your file path with csv files
#csv.directory <- "C:/Users/KristineT.SCCWRP2K/SCCWRP/SD Hydro Vulnerability Assessment - General/Data/RawData/USGS_STIC_Data_Hydroperiod/SCCWRP_CSV_test/Otay/" #update with your file path with csv files
#csv.directory <- "C:/Users/KristineT.SCCWRP2K/SCCWRP/SD Hydro Vulnerability Assessment - General/Data/RawData/USGS_STIC_Data_Hydroperiod/SCCWRP_CSV_test/Roblar Creek/" #update with your file path with csv files
#csv.directory <- "C:/Users/KristineT.SCCWRP2K/SCCWRP/SD Hydro Vulnerability Assessment - General/Data/RawData/USGS_STIC_Data_Hydroperiod/SCCWRP_CSV_test/Santa Margarita/" #update with your file path with csv files

## Jessica's directories:
#csv.directory <- "/Users/ppsp/Desktop/SCCWRP/Kris/USGS Flow/STIC CSV/Galloway Valley/" #update with your file path with csv files
#csv.directory <- "/Users/ppsp/Desktop/SCCWRP/Kris/USGS Flow/STIC CSV/Santa Margarita/" 
#csv.directory <- "/Users/ppsp/Desktop/SCCWRP/Kris/USGS Flow/STIC CSV/Roblar Creek/"


#Set working directory to csv.directory
setwd(csv.directory)
#Set output directory where outputs should be saved - subfolder within csv directory
output.directory <- paste0(csv.directory, "Outputs")
#Create output directory (if does not exist already), this creates a new output folder where plots and files to be saved
dir.create(output.directory)

# [USER DEFINED] Define the site name
site.name <- "Beaver_Hollow"

# [USER DEFINED] type in quotes if you are using a "MAC" or "PC".  Alternative: if using PC, uncomment (remove #) line with "PC" and comment (add # in front of line) line with "MAC" 
#OS.pc.mac <- "MAC" #change to "MAC" if using MAC
OS.pc.mac <- "PC" #change to "MAC" if using MAC

#List the csv files associated with the site 
  #(USER DEFINED until lookup table with serial #, date range, and site.name is created)
  #if manually listing csv files for each series, list csv file names below line in quotes and uncomment (remove #) and run next line. Be sure to comment (add #) in front of the line 3 lines down
  #csv.file.list <- c("", "", "", "", "") 
  #if all files saved in csv.directory are for a given site, then list all files in directory and run line below
  csv.file.list <- list.files(csv.directory, pattern=".csv")

# [USER DEFINED] Define thresholds based on %RC-Tc Plots and site condition for each series data,
  #iterative process. Start with defaults then update based on plot1 graphs produced in loop.
#Set Wet/Dry Threshold (%RC): Subjective criterion for what %RC is the minimum for wet 
  #readings taking into consideration graphed data and site conditions.
  #wetdry_threshold_all is a default list of wet/dry thresholds for each series from 1 to i number of series, 
  #if updating threshold for series 1, update first value in list, series 2 is 2nd value in list, etc.
  #User updates these thresholds after evaluating graphed data plot1 from loop, run loop with defaults initially to determine if adjustments to thresholds are necessary
  #Note: if more than 10 series, add threshold values accordingly to wetdry_threshold_all, percentRCcutoff, and lower_percentRCcutoff
  wetdry_threshold_all <- c(10, 10, 10, 10, 10, 10, 10, 10, 10, 10) 
#Set %RC cutoff and %RC cutoff lower
  #Allows use of upper and lower bounds to limit ringing. 
  #If ringing observed, change percentRCcutoff_all. Usually 10% to 20% cutoff will be sufficient, enter values 10 or 20
  #If ringing observed & STIC goes dry, enter lower cutoff value to include true "dry" values 1 or 2
  #Default values are set to 0, evaluate cutoff and lower cutoff based on evaluating plot1 from loop, run loop with defaults initially and update as needed
  percentRCcutoff_all <- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  lower_percentRCcutoff_all <- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  
  
  
##############################################################################
#loop through each csv file in the directory (series) to be evaluated for given site, make plots and calculations for each series

#first, create empty output dataframe where Summary Stats will be saved from each series (information in SummaryChart tab)
#total number of columns = number of series + 1 (first column is total column)
total.col.num <- length(csv.file.list) + 1
#List of row names (variable names in summary stats)
row_names <- c("RecordSubtotals", "Logger Start Date", "Count of Wet Records", "Count of Dry Records", "% Wet", 
                           "Days Wet", "Days Dry", "Max continuous wet", "MCW Days")
#output summary table blank that each series summary stats will be saved to
SummaryStats.Output <- data.frame(matrix(NA, nrow=length(row_names), ncol=total.col.num))
#set row names in output df
row.names(SummaryStats.Output) <- row_names
#set names of columns (total, series#)
#create list of series numbers 1 to total number of series or csv files
series.list <- paste0("Series ", 1:length(csv.file.list))
#save column names
names(SummaryStats.Output) <- c("Total", series.list)

#create output series_data table containing all calculated variables from each series, start off blank, 
#will add values at end of loop iterations
#column names
series_data_colnames <- c("Date_Time", "Temp_C", "Intensity_Lux",
                           "Date", "STIC_serial", "TempCorrected",      
                           "pct_Rctempcorrected", "Wet_Dry", "Series")
#create empty data frame to save series data to
series_data_all <- data.frame(matrix(NA, nrow=1, ncol=length(series_data_colnames) ))
#set column names
names(series_data_all) <- series_data_colnames
  
#create output vector combining the WetDry columns from all series - used to calculate total consecutive wet dry record and days
WetDry_all <- NA

#loop through each csv file and series from series i: 1 to length of csv files (series)
for(i in 1:length(csv.file.list)){
  
  #to test out one iteration of loop, do not run "for(i in 1:length(csv.file.list)){" line above, skip to following line where you set i as an iteration number then run all lines within loop to troubleshoot
  #i=1
  #i=2
  #i=3
  
  ###########################################################################################################
  ####STICs-ALL Data Tab found in xlsx 
  
  #Read in CSV for series i
  csv_data <- read.csv(csv.file.list[i])
  #find original column header names
  orig.colnames <- names(csv_data)
  
  #Clean column names and rename
  csv_data <- csv_data %>%
    clean_names() %>% 
    #rename columns of importance
    dplyr::rename(Date_Time = x,
                  Temp_C=x_1,
                  Intensity_Lux=x_2)

              
  #Remove first row of original unused column names 
  csv_data <- csv_data[-c(1), ]
  
  #Create new data frame using only Date, Temp_C, Intensity_Lux columns from csv
  series_data <- csv_data %>% 
    select(Date_Time,Temp_C,Intensity_Lux) %>% 
    #Create column with date only, removes timestamp
    mutate(Date = as.Date(Date_Time, format = "%m/%d/%y"))
  
  #find logger start date
  logger.start.date <- format(series_data$Date[1], "%m/%d/%Y") 
  
  #Find the serial number from the original csv first column name which is formatted "i_plot_title_serial#" for PC or "plot_title_" for MAC
  # if working on a PC, then find and replace "i_plot_title_" with " to get serial #
  if(OS.pc.mac == "PC"){
    STIC_serial <- gsub("i_plot_title_","",colnames(csv_data)[1]) #for PC
  #else, if on a MAC, replace "plot_title_" with "" to get serial #
    }else{
    STIC_serial <- gsub("plot_title_","",colnames(csv_data)[1]) #for MAC
  }
  #Add serial number as a column to output dataframe
  series_data$STIC_serial <- rep(STIC_serial,length(series_data$Date))
  
  #Convert Temperature from character to numeric format
  series_data$Temp_C <- as.numeric(series_data$Temp_C)
  
  #Calculate mean temp
  Temp_Cmean <- mean(series_data$Temp_C)
  
  #Change temp from F to C if Temp_Cmean is > 35
  series_data <- series_data %>%
    mutate(Temp_C= 
             if(Temp_Cmean > 35){
               ((Temp_C-32)* (5/9))
             }else{
               Temp_C
             }
    )

  
  #Format Intensity_Lux (contains , in values, remove and save as numeric vector) 
  series_data$Intensity_Lux <- gsub(',', '', series_data$Intensity_Lux)
  #Convert Intensity_Lux from character to numeric
  series_data$Intensity_Lux <- as.numeric(series_data$Intensity_Lux)
  
  #attach column names in series_data so you can run analysis by using column name only
  attach(series_data)
  
  #apply function to achieve Temp Corrected value
  series_data <- series_data %>% 
    mutate(TempCorrected = 
             Intensity_Lux/(1+((2.1/100)*((Temp_C)-25)))
           )
  
  #create max temperature corrected variable
  maxTC <- max(series_data$TempCorrected)
  
  #create an equation to use for %RCtempcorrected conditional statements
  temp_equation_1 <- (series_data$TempCorrected/(maxTC*100))
  
  #Set "lower % RCcutoff" and "% RCcutoff" numbers based on user-defined lists outside of loop, ith values associated with series i
  # May need to adjust RC cut offs set outside of loop after looking at "plot1"
  percentRCcutoff <- percentRCcutoff_all[i]
  lower_percentRCcutoff <- lower_percentRCcutoff_all[i]
  
  #Conditional statements to calculate %relative conductivity temp corrected [pct_Rctempcorrected]
  #(note: %Relative conductivity (%RC) uses highest temp corrected raw 'lux' value as 100%)
  series_data <- series_data %>%
    mutate(pct_Rctempcorrected =
             case_when(
               #conditional statement that states if temp_equation_1 is less than or equal to
               # the lower_percentRCcutoff then preform this equation: (TempCorrected/MaxTC*100)
               temp_equation_1 <= "lower_percentRCcutoff" ~ (TempCorrected/maxTC*100),
               #if temp_equation_1  > percentRCcutoff then perform this equation: (TempCorrected/MaxTC*100)
               temp_equation_1 > "percentRCcutoff" ~ (TempCorrected/maxTC*100),
               #if not either of two conditions, then it will output an NA
               #temp_equation_1 > "lower_percentRCcutoff" & temp_equation_1 < "percentRCcutoff" ~ "NA"
               
             )
    )

  
  ####################################################
  ###Plot time series of %RC-temp corrected and Temp C
  
  #Coefficient to multiply second axis constraints by
  coeff <- .275
  #Colors for lines
  Tempcolor <- "red"
  pct_RCtemp_color <- "blue"
  
  #Creates plot and output
  plot1 <- ggplot(series_data, aes(x=Date)) +
    geom_line( aes(y=Temp_C/coeff, colour="Temperature"),size=1,) + 
    geom_line( aes(y=pct_Rctempcorrected ,  colour="% RC Temp Corrected"),size=1,) +
    scale_y_continuous(sec.axis = sec_axis(~.*coeff, name="Temperature (°C)")) + 
    scale_x_date(date_labels="%m/%d/%y",date_breaks  ="1 month") +
    scale_colour_manual(values = c("blue", "red"), name="") +
    labs(y = "% RC-temp corrected",
         x = "Date") +
    theme_bw() +
    theme(axis.line = element_line(colour = "black"),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.background = element_blank(),
          legend.position = "top") 
  
  #Print plot
  print(plot1)
  
  #Set file name and save plot as file name
  file.name <- paste0(output.directory,"/", site.name, "_series", i,"_RC_tempcorrected_timeseries_plot", ".png")
  ggsave(plot1, file = file.name, width=10, height=4)
  
  
  ####################################################
  ###Plot time series of SpCond-temp corrected and Temp C
  ### No SpCond to plot, skip
  
  
  
  
  ####################################################
  #Manually set wet/dry threshold [USER DEFINED in wetdry_threshold_all outside of loop, takes value i for series i]
    #Subjective criterion for what %RC is the minimum for wet readings taking into consideration graphed data (plot1) and site conditions.
  wetdry_threshold <- wetdry_threshold_all[i]
  
  #Create wet_dry column. 0 for dry, 1 for wet 
  series_data <- series_data %>%
    mutate("Wet_Dry"= 
             #When pct_Rctempcorrected is greater than the wetdry threshold assign a 1, meaning wet
             #When pct_Rctempcorrected is less than the wetdry threshold assign a 0, meaning dry 
             case_when(
                       pct_Rctempcorrected > wetdry_threshold ~ (1),
                       pct_Rctempcorrected < wetdry_threshold ~ (0)
                       )
          )
  
  #save Wet_Dry for series i in output vector WetDry_all
  WetDry_all <- c(WetDry_all, series_data$Wet_Dry)
  
  ###########################################################################################################
  ####Summary Chart ####
  #calculates summary statistics from Serial i saved in SummaryChart tab in xlsx and saves into output dataframe
  
  #Find the number of readings that registers as wet, 
  #but have more than 10 readings in a day (5 hours)
  consecutive_wet <- series_data %>% 
    #group by wet dry column and date
    group_by(Wet_Dry, Date) %>%
    # summarise total number of wet readings for a date
    summarise(count = sum(Wet_Dry==1)) %>%
    # only include days with greater than 10 wet readings 
    filter(count > 10) 
  
  
 ################### 
  wet_run_data <- series_data %>%
    select(Date, Wet_Dry)
  #gives a list of consecutive wet and dry days. values: Wet is TRUE, Dry is FALSE. Length is total number
  # of consecutive days dry or wet
  consec_wetdry_records = rle(wet_run_data$Wet_Dry > 0)
  # which length is TRUE (wet) and has a length greater than or equal to 10
  index_consec_recwet = which(consec_wetdry_records$values == TRUE & consec_wetdry_records$lengths >= 10)
 
   # total number of consecutive wet readings (Max continuous wet)
  consecutive_wet <- max(consec_wetdry_records$lengths[index_consec_recwet])
  
  #selects and sums all days that register as wet (Wet_Dry==1)
  count_wet_records <- series_data %>% group_by(Wet_Dry, Date) %>%
    summarise(count = sum(Wet_Dry==1))
  
  #days wet
  #Divide the number of wet records by 48 (since there are 48 readings a day) to get wet days
  #then round the number to nearest whole value
  cons_wet_days <- as.numeric(round_half_up(count_wet_records/48))
  
  #Sum all of the count data together, save as numeric
  count_wet_records <- as.numeric(sum(count_wet_records$count))

  #Total number of recordings (wet and dry) taken by STIC logger, saved as numeric
  RecordSubtotals <- as.numeric(nrow(series_data))
  
  #Subset series data to only dry records pct_Rctempcorrected <1
  subset_Dry_Records <- series_data %>%
    filter(pct_Rctempcorrected < 1) 
  
  #Find total number of dry records  
  Count_Dry_Records <- length(subset_Dry_Records$Date_Time)
  
  #Total number of dry days and rounds to nearest whole number (up and down) - 48 records/day
  Days_Dry <- round_half_up(Count_Dry_Records/48)
  
  #Selects the maximum number of consecutive wet records 
  max_continuous_wet <- max(consecutive_wet)
  
  #Selects maximum continuonus wet days 
  MCW_Days <- max(round_half_up(max_continuous_wet/48))
  
  #Calculates percent of days that were wet
  pct_wet <- round(count_wet_records/(count_wet_records+Count_Dry_Records)*100, digits=0)
  
  #combine summary stats into a common vector and save into output dataframe
  Summary.Stats <- c(RecordSubtotals, logger.start.date, count_wet_records, Count_Dry_Records, pct_wet, 
                     cons_wet_days, Days_Dry, max_continuous_wet, MCW_Days) 
  
  #save summary stats from series i as column i+1 [reminder: first column is total and will be calculated outside of loop once all series stats generated]
  SummaryStats.Output[,i+1] <- Summary.Stats
  
  #Write csv for series_data output generated for series i 
  file_name3 <- paste0(output.directory,"/SanDiegoSTICsDataProcess_Sets_Series", i, "_", site.name, ".csv")
  write.csv(series_data, file = file_name3, row.names = FALSE)
  
  #save series data in overall output table, add in column with series i
  #series column for output table
  series.i <- rep(paste0("Series ", i), length(series_data[,1]))
  #add series to series_data
  series_data <- series_data %>% 
    mutate(Series = rep(paste0("Series ", i), length(Date_Time)) )
  #append or bind rows from series_data to series_data_all output dataframe
  series_data_all <- rbind(series_data_all, series_data)
  
}


##############################################################################
#Summary Stats across all series

#add totals to the output dataframe (first column that gets total stats)
#Record Subtotals: sum of all series RecordSubtotals
RecordSubtotals <- sum(as.double(SummaryStats.Output[1,]), na.rm=TRUE)
#logger start date blank
logger.start.date <- NA
#sum of remaining variables across all series [rows for each variable in summary table]
count_wet_records <- sum(as.double(SummaryStats.Output[3,]), na.rm=TRUE)
Count_Dry_Records <- sum(as.double(SummaryStats.Output[4,]), na.rm=TRUE)
pct_wet <- round(count_wet_records/(count_wet_records+Count_Dry_Records)*100, digits=0)

cons_wet_days <- sum(as.double(SummaryStats.Output[6,]), na.rm=TRUE)
Days_Dry <- sum(as.double(SummaryStats.Output[7,]), na.rm=TRUE)
max_continuous_wet <- NA
MCW_Days <- NA

#combine all values for total column and paste into Summary.Stats.Output
Summary.Stats <- c(RecordSubtotals, logger.start.date, count_wet_records, Count_Dry_Records, pct_wet, 
                   cons_wet_days, Days_Dry, max_continuous_wet, MCW_Days)

#save summary stats from total as column1 
SummaryStats.Output[,1] <- Summary.Stats

#Max consecutive wet records (on Workspace tab in xlsx), use WetDry_all vector to calculate
max.consec.wet.records.all <- max_continuous_wet

#Max consecutive wet days (on Workspace tab in xlsx)
max.consec.wet.days.all <- max.consec.wet.records.all / 48


file_name4 <- paste0(output.directory,"/SanDiegoSTICsDataProcess_Output_Summary" , "_", site.name, ".csv")
write.csv(SummaryStats.Output, file = file_name4, row.names = TRUE)
#####################################################################
###Overall %RC and TempC plot for all series - Plot in SummaryChart tab in xlsx
#include logger start/reset (using row 2 from SummaryStats.Output)
#plot data from series_data_all

#Coefficient to multiply second axis constraints by
coeff <- .275

#Colors for lines
Tempcolor <- "red"
pct_RCtemp_color <- "blue"

#Set series data all date_time to correct format of Date
series_data_all$Date_Time <- as.Date(series_data_all$Date_Time, format = "%m/%d/%y")

#Logger start date points to add to summaryplot
logger.dates <- SummaryStats.Output[2,]
#exclude NA values
logger.dates <- logger.dates[!is.na(logger.dates)]
#format as date
logger.dates <- as.Date(logger.dates, format =  "%m/%d/%Y")
#plot logger start dates on the y axis = 0
y <- rep(0, length(logger.dates))
#dummy ID column for legend
type <- rep("Start Date", length(logger.dates))
#make a dataframe for logger start dates
start.dates <- logger.dates %>% 
  bind_cols(y, type) %>% 
  data.frame()
names(start.dates) <- c("start.date", "y", "type")

#Creates plot and output
summaryplot <- ggplot(series_data_all, aes(x=Date_Time)) +
  geom_line( aes(y=Temp_C/coeff, colour="Temperature"),size=1,) + 
  geom_line( aes(y=pct_Rctempcorrected ,  colour="% RC Temp Corrected"),size=1,) +
  scale_y_continuous(sec.axis = sec_axis(~.*coeff, name="Temperature (°C)")) + 
  scale_x_date(date_labels="%m/%d/%y",date_breaks="4 month",) +
  scale_colour_manual(values = c("blue", "red"), name="") +
  labs(y = "% RC-temp corrected",
       x = "Date") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust=1))+
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        legend.position = "top") +
  geom_point(data=start.dates, aes(x=start.date, y=y, shape=type), color="green",  size=3) +
  scale_shape_manual(values = 17, labels="Logger Start/Reset", name="")

#Print plot
print(summaryplot)

#Set file name and save plot as file name
file.name <- paste0(output.directory,"/", site.name, "_series_all", i,"_RC_tempcorrected_timeseries_plot", ".png")
ggsave(summaryplot, file = file.name, width=10, height=5)
